Author: James Park
[Q0]: If the wrong encoding is selected as output, then the wrong bit extraction will occur. For example, an I-type instruction will use instruction[30:20] with the MSB sign-extended while an S-type instruction uses instruction[30:25] and instruction[11:7] with the MSB sign-extended. Having the wrong bit extraction will result in the incorrect immediate value being calculated, which results in the processor incorrectly calculating wrong memory addresses and arithmetic results. R-type instruction does not use any immediate values since it uses 2 register operands, so the immediate value is set as don't cares.
[Q1]: Some formats like J-type and B-type are hardcoded to zero because in RISC-V branch and jump target addresses are 2-byte aligned so hardcoding it to zero allows for these immediate values to be 2-byte aligned. Also by hardcoding a zero in the LSB, this allows for the immediate value to be shifted left once, so that the range of values it spans is larger, since the LSB will always be 0. This effectively doubles the range of values the immediate can cover. By removing this optimization, then the LSB will have to be used to represent 0, which will reduce the added range by half and also waste space since this value will always be 0. 
[Q2]: I think that some instruction formats have complex immediate encodings to ensure the register and opcode bits are the same across all instruction formats, i.e. rd at [11:7] and opcode at [6:0]. By ensuring that these values are constant at all times, other units like the register file can be ran parallel with the instruction decoding. This parallelism allows for faster processing by reducing the potential longest critical path.
[Q3]: If one tries to write to x0 (the hardwired zero register) then the write should be ignored. For the overall performance of the processor, it is beneficial to keep a constant zero source since it is a frequently accessed value. By ignoring writes to this register rather than generating an error, the processor can continue executing instructions without interruption. This improves overall efficiency and avoids unnecessary faults.
[Q4]: The program counter is not included in the register file because the overall function of the PC differs from the general purpose registers in the register file. The program counter keeps tracks of every instructions and at the minimum, it is being incremented by 4 after every instruction. There are cases in jumps and branches where the PC behaves differently which requires separate control logic, and this also differs from the read/write model of the register file. Also by having the PC in the register file, this reduces the count of the general purpose registers by 1, which can conflict with the register file logic since you need to account for the control logic of the PC.
[Q5]: In order to increase or decrease the number of registers in the register file, one would need to modify the ISA encoding, which allocates exactly 5 bits per register field. For example, if we wanted to support 64 registers, each register field would need to be 6 bits, taking bits from the immediate, opcode, and function fields. This can cause issues by limiting the range of values that are supported in the immediate, function, and opcode fields. On the contrary, if we wanted to support 16 registers, then the register fields would be reduced to 4 bits. This can cause issues because there may not be enough registers to support the ISA, causing more register spills to memory.
[Q6]: To write a processor that implements the RV32I ISA, the register file will act as the data storage, as it can read and access the register values, and it also connects to the ALU, supplying operands for its operation. The immediate decoder will extra and sign-extend the immediate values from the instruction, depending on the type. This allows the processor to perform arithmetic operations with immediate values, like addi, perform memory calculations for load/store, calculate branch/jump addresses, and perform load upper immediate instructions. The ALU is the main computational driver, as it performs arithmetic, logical, shift, and comparison operations, while also generating certain control logic like o_eq and o_slt. It also performs the calculation of the memory addresses in loads/stores. Some other major components needed to build this include the program counter, data memory, instruction memory, control unit, and multiplexers to determine certain paths to take. 
[Q7]: To create a hardware multiply instruction, I would first start with moving the multiply logic into the ALU, by doing shift and add operations in parallel using combinational circuits. This ensures now that the ALU can handle all operations and may be a potentially better option area wise than adding a separate multiplier structure because it can reuse components. Then I would add a new ALUop signal that selects the multiplication operation and a new R-type instruction for the operation. This new instruction can be based similar to add/subtract by taking the same opcode value and giving it a new funct value. The instruction fetch and control unit would also need to be updated to recognize the new MUL instruction by detecting its new specific opcode/funct field and generating specific control signals.
[Q8]: In order to support 16-bit instructions in addition to the 32-bit instructions, there would need to be a lot of changes to the immediate encoder, while the register file and ALU have no changes. The immediate encoder would need to be able to detect the instruction format (original vs. compressed instructions), need to extract immediates from different positions, and require more sign-extension since the immediates aren't the same length. The register file can stay the same because it will still be accessing the same general-purpose registers, but most likely a smaller number of registers within the 32 registers since the register fields are less bits. This, theoretically, would be abstracted away from the register file which would require no changes to it specifically. The ALU has no changes as well because the operands will remain 32-bits and the type of operations does not change because we added 16-bit instructions. The big change comes in the instruction decoding and handling the 16-bit instruction appropriately, but this is abstracted away from the ALU and its function stays largely the same.