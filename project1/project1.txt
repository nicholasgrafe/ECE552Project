Author: James Park
[Q0]: No, the result in a0 is not always the correct and complete product of the two 32-input numbers because two 32-bit numbers multiplied can create at most a 64-bit product. Since we are only returning the lower 32-bits, if the multiplication results in overflow, then we are not representing the full, correct product.
[Q1]: You can perform a modulo (%) operation to find the remainder of a division problem. To implement this, it would be very similar to the mystery problem as we can do a loop that does repeated subtraction, and instead of keeping a counter for the quotient, we can return the remaining value in the number that is being subtracted from as the remainder.
[Q2]: Introducing a mul operation can increase performance since we are decreasing the number of instructions, which also improves code efficiency. A downside of adding a mul operation is the increase in logic gates compared to simple shifts and additions that can be performed by an Arithmetic Logic Unit (ALU).
[Q3]: A difference between RV321 and IA-32 is that IA-32 allows register and memory operands in operations, so in an add instruction it can use a value at a memory address to a register directly. RV321 uses only loads and stores to access memory addresses and requires a register to store that value. Another difference is that IA-32 only uses 8 general purpose registers, while RV321 has 32 registers that serve as different storage types. Having more registers like in RV321 provides flexibility to the user. Finally, the instruction encoding between IA-32 and RV321 differ. In RV321, there is a constant 32-bit binary instruction that will follow one of the three formats (R, I, or J). Meanwhile IA-32 has a variable-length format, which can differ based on the opcode, displacement/immediate values, address/operand specifiers, or the presence of prefixes.
[Q4]: A key difference between a high-level language such as C and a low-level language such as RISC-V, includes abstraction. In high-level languages like C, there is human-readable syntax, data structures, and portable libraries that hide a lot of the layers of code that users do not see, while in RISC-V users are using specific instructions (i.e. lw/sw) that interact directly with the processor's hardware operations. Another key difference is in portability, as high-level languages like C are created for multiple architectures and RISC-V is specific to a RISC-V processor. The last key difference is memory management. RISC-V is dealing directly with the registers, whether it is assigning registers or accessing register values, while in C there are variables and pointers that deal with storing values.
[Q5]: The software components that allow the C code written to be realized as machine instructions that can be executed by a processor are the preprocessor, compiler, assembler, and linker. The compiler design plays a large role in the overall performance because it handles optimizing the code to use the most efficient instructions, reorder instructions to prevent any CPU stalls, and deals with efficiently managing the registers. The linker design can also impact performance because it allows the compilation process to optimize across multiple files, which prevents the compiler from only optimizing individual files. It can also affect the cache performance by placing frequently called instructions near each other in memory for better spatial locality.
[Q6]: Adding a hardware multiplication instruction would effect programs that do not require multiplication as extensively because it also adds more complicated hardware, which can increase the the overall clock cycle time due to the potential increase of the critical path. This would cause programs that do not rely on the multiplication operation as frequently to run slower than running it on a simple processor without this operation.
[Q7]: This program is doing a Fahrenheit to Celsius conversion. Specifically it is using C = (x-32)(5/9). This is seen because the first line sets a value temp register to 32 then performs (argument - 32). Then it multiplies by 4 and adds the value of (argument -32) again to multiply by five. Finally the loop is performing division by subtraction, which loops 5(argument-32) - 9 until that value is less than 9 and it adds 1 to the quotient to return.
[Q8]: Since this first code is performing a F to C conversion, to do the opposite (C to F) we would start by multiplying a0 by 8 using a slli by 8 and adding another a0 to get a0 * 9. I would continue to reuse the the idea of a repeated subtraction loop, but this time I would set the divisor to be 5 and continue to loop until the remaining value of a0 is less than 5. At this point, we have (a0 * 9) / 5 and then I would add 32 and transfer the final value back to a0 to return. This now gives us F = (C * 9)/5 + 32.
[Q9]: A hardware improvement I would make to this particular program to make it run faster is adding a hardware division operation. By adding a division operation, this would eliminate the need for the repeated subtraction loop to find the quotient since we can run a single instruction. Another benefit is that the loop scales with the a0, since the larger a0 gets the slower it takes to compute the loop. By having a single hardware operation, the compute time of this operation would be in a fixed number of cycles.